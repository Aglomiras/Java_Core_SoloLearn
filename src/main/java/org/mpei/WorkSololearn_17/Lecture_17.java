package org.mpei.WorkSololearn_17;

public class Lecture_17 {
    /**
     * МОДИФИКАТОР VOLATILE
     * В синтаксисе java есть два ключевых слова для работы с многопоточностью - volatile и synchronized.
     *
     * Начнём с volatile, он является модификатором для поля:
     * volatile int statusCode = 4;
     * volatile User admin;
     *
     * Изменение volatile переменной сразу видны всем потокам. Это одно из решений проблемы видимости
     *
     * private volatile int value;
     *
     * public void setValue(int value) {
     *     this.value = value;
     * }
     *
     * public int getValue() {
     *     return value;
     * }
     *
     * Метод getValue() будет всегда возвращать актуальное значение переменной value.
     * Даже если другой поток обновил его всего 0,000001 секунды назад.
     *
     * Поможет ли volatile решить все проблемы этого кода?
     * Нет! Метод switchFlag раскладывается на три действия:
     * - Прочитать текущее значение isActive во временную переменную (пусть это будет tmp)
     * - Изменить значение tmp на противоположное
     * - Записать в переменную isActive значение переменной tmp
     *
     * volatile поможет другим потокам увидеть изменения переменной, но не помешает
     * другим потокам ворваться в середине процесса.
     *
     * После двух switchFlag() ожидаем увидеть true, но при неудачном тайминге можно получить false.
     * volatile помогает решить проблему видимости. Но если новые значения вычисляются, а не просто
     * присваиваются, возможна ошибка "потерянный апдейт":
     *
     * volatile int value;
     *
     * value = 5;          // всё будет ок
     * value = value + 5;  // возможен потерянный апдейт
     * */
}
