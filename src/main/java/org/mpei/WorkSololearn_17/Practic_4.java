package org.mpei.WorkSololearn_17;

public class Practic_4 implements Runnable {
    /**
     * Тестовый вопрос №4:
     * */
    /**
     * Вспомним урок про потоки и их прерывание. На всякий случай напомню схему остановки потока:
     * - Поток t1 выполняет какую-то работу
     * - Код в потоке t2 хочет остановить работу потока t1 и вызывает метод t1.interrupt()
     * - Поток t1 внутри своего кода проверяет статус прерывания с помощью метода isInterrupted()
     */
    boolean interrupted; //Нужен ли для данной переменной модификатор volatile

    public void interrupt() {
        //...
        interrupted = true;
    }

    public boolean isInterrupted() {
        return interrupted;
    }

    @Override
    public void run() {

    }

    /**
     * Варианты ответа:
     * 1) Да, чтобы несколько потоков не перетёрли изменений друг друга;
     * 2) Да, чтобы другой поток при вызове isInterrupted получил актуальное значение флажка;
     * 3) Нет, потому что прерывание организовано на уровне ОС;
     * 4) Нет, потому что вся работа идёт в рамках одного потока;
     *
     * Правильный ответ:
     * 2)
     *
     * Верно, методы interrupt() и isInterrupted()  вызываются из разных потоков.
     * Чтобы isInterrupted() вернул актуальное значение, у поля interrupted стоит модификатор volatile
     * */
}
