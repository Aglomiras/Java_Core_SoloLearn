package org.mpei.WorkSololearn_11;

import java.util.ArrayList;
import java.util.LinkedList;

public class Lecture_11 {
    public static void main(String[] args) {
        /**
         * -----ПОТОКИ-----
         * Java является многопоточным языком программирования.
         * Это значит, что наша программа может осуществлять оптимальное использование доступных ресурсов,
         * запуская два и более компонентов одновременно, в то время, как каждый компонент обрабатывает разное задание.
         *
         * Вы можете подразделить специфические операции внутри одного приложения в индивидуальные потоки, которые все запускаются параллельно.
         *
         * Существует два способа создать поток.
         * 1. Расширение класса Thread
         * Наследуйтесь от класса Thread, переопределите его метод run(), и напишите функциональность потока в методе run().
         * Затем вы создаете новый объект вашего класса и вызоваете метод start, чтобы запустить поток.
         * Пример рассмотрен в папке Starter
         *
         * Каждый Java поток расположен в порядке очередности, чтобы помочь операционной системе определить порядок потоков.
         * Значение приоритета располагается от 1 до 10, по умолчанию для каждого потока установлен приоритет 5.
         * Вы можете установить приоритет потока с помощью метода setPriority().
         *
         * 2. Другим способом создания Потоков является реализация интерфейса Runnable.
         *
         * Реализуйте метод run(). Затем, создайте новый объект Thread,
         * передайте класс Runnable в его конструктор, и запустите поток, путем вызова метода start().
         * Пример рассмотрен в папке Starter_1
         *
         * Метод Thread.sleep() останавливает поток на определенный период времени. Например, вызов Thread.sleep(1000); останавливает поток на одну секунду.
         * Не забывайте, что Thread.sleep() бросает исключение InterruptedException, так что убедитесь, что оно окружено блоком try/catch.
         *
         * Может казаться, что реализация интерфейса Runnable немного сложнее, чем расширение от класса Thread.
         * Однако, реализация интерфейса Runnable является предпочтительным способом запустить поток, потому что
         * она также позволяет вам расширяться от другого класса.
         *
         * -----ТИПЫ ИСКЛЮЧЕНИЙ-----
         * Существует два типа исключений, проверяемые (checked) и непроверяемые (unchecked) (также называются runtime).
         * Главным отличием является то, что checked исключения проверяются при компиляции, а unchecked исключения проверяются во время запуска.
         *
         * Как было упомянуто в предыдущем уроке, Thread.sleep() бросает исключение InterruptedException.
         * Это пример checked исключения. Ваш код не скомпилируется, пока вы не обработаете исключение.
         *
         * Мы видели примеры unchecked исключений, которые проверяются во время запуска, раннее. Пример (попытка деления на 0):
         * Хорошо знать типы исключений, потому что они могут помочь вам быстрее отлаживать ваш код.
         * Подробнее про все виды исключений (Exception) здесь: https://javarush.com/quests/lectures/questsyntaxpro.level14.lecture03
         *
         * -----ArrayList-----
         * Java API предоставляет специальные классы для хранения и управления группами объектов. Одним из таких классов является ArrayList.
         * Стандартные Java массивы имеют фиксированную длину, что означает, что после их создания они не могут быть расширены, или уменьшены.
         * С другой стороны, классы ArrayList создаются с первоначальным размером, но если размер превышается, то коллекция автоматически увеличивается.
         * Когда объекты удаляются, ArrayList может уменьшиться в размере. Обратите внимание, что класс ArrayList находится в пакете java.util,
         * так что необходимо его импортировать до использования.
         * Создадим ArrayList.
         * */
        ArrayList colors = new ArrayList();
        /**
         * Вы можете опционально определить емкость и тип объектов, которые будет содержать класс ArrayList:
         * */
        ArrayList<String> colors1 = new ArrayList<String>(10);
        /**
         * В вышеуказанном коде определяется ArrayList переменных типа String с 10 в качестве его начального размера.
         * ArrayLists хранит объекты. Таким образом, указанный тип должен быть типом класса. Вы не можете передать, например тип int, в качестве типа объекта.
         * Вместо этого, используйте специальные типы классов, которые соответствуют желаемому типу значения,
         * например Integer для int, Double для double, и так далее.
         *
         * Класс ArrayList предоставляет множество полезных методов для управления его объектами.
         * Метод add() добавляет новые объекты классу ArrayList. И наоборот, метод remove() удаляет объекты из класса ArrayList.
         * */
        ArrayList<String> colors2 = new ArrayList<String>();
        colors2.add("Red");
        colors2.add("Blue");
        colors2.add("Green");
        colors2.add("Orange");
        colors2.remove("Green");
        System.out.println(colors2);
        /**
         * К другим полезным методам относятся следующие:
         * - contains(): Возвращает «верно», если список содержит указанный элемент
         * - get(int индекс): Возвращает элемент на указанной позиции в списке
         * - size(): Возвращает число элементов списка
         * - clear(): Удаляет все элементы из списка
         *
         * Обратите внимание: Также как и с массивами, индексирование начинается с 0.
         *
         * -----LinkedList-----
         * LinkedList очень похож по синтаксису на ArrayList.
         * Вы можете легко изменить ArrayList на LinkedList, изменив тип объекта.
         * */
        LinkedList<String> c = new LinkedList<String>();
        c.add("Red");
        c.add("Blue");
        c.add("Green");
        c.add("Orange");
        c.remove("Green");
        System.out.println(c);
        /**
         * Вы не можете определить начальный размер для LinkedList.
         *
         * -----LinkedList против ArrayList-----
         * Наиболее заметная разница между LinkedList и ArrayList находится в их способах хранения объектов.
         * ArrayList лучше для хранения и получения доступа к информации, так как он очень похож на обычный массив.
         * LinkedList лучше для манипулирования информацией, типа создания множества вставок и удалений.
         *
         * В дополнении к хранению объекта, LinkedList хранит адрес памяти (или ссылку) элемента, который за ним следует.
         * Он называется LinkedList (связанный список), потому что каждый элемент содержит ссылку на соседний элемент.
         *
         * Вы можете использовать улучшенный цикл for для итерации по его элементам.
         * */
        for (String s : c) {
            System.out.println(s);
        }
        /**
         * В итоге:
         * - Используйте ArrayList, когда вам необходим быстрый доступ к вашей информации.
         * - Используйте LinkedList, когда вам необходимо сделать большое количество вставок и/или удалений.
         * */
    }
}
