package org.mpei.WorkSololearn_7;

public class Lecture_7 {
    public static void main(String[] args) {
        /**
         * -----ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ-----
         * Как мы видели в предыдущем уроке, подкласс может определить поведение, специфичное к типу подкласса,
         * что значит, что подкласс может реализовать метод родительского класса, основанный на его требованиях.
         * Эта особенность известна, как переопределение методов.
         *
         * Пример разобран в папке Starter
         *
         * Правила Переопределения Методов:
         * - Должны иметь одинаковые возвращаемый тип и аргументы
         * - Уровень доступа может быть более ограничивающим, чем уровень доступа переопределенных методов. (Например: Если метод суперкласса объявлен как public, то переопределенный метод в подклассе не может быть ни private ни protected)
         * - Метод, объявленный с помощью ключевых слов final или static не может быть переопределен
         * - Если метод не может быть наследован, то он не может быть переопределен
         * - Конструкторы не могут быть переопределены
         *
         * Переопределение методов также известно, как полиморфизм времени выполнения.
         *
         * -----ПЕРЕГРУЗКА МЕТОДОВ-----
         * Случай, когда методы имеют одинаковое имя, но разные параметры, известен, как перегрузка методов.
         * Ее использование очень полезно, когда вам необходима одинаковая функциональность метода для разных типов параметров.
         *
         * Следующий пример иллюстрирует метод, который возвращает наибольший из двух параметров.
         * */
    }

    int max(int a, int b) {
        if (a > b) {
            return a;
        } else {
            return b;
        }
    }

    /**
     * Отображенный выше метод будет работать только с параметрами типа int.
     * Однако, возможно мы захотим использовать его также и для типа double. Для этого вам необходимо перегрузить метод max:
     */
    double max(double a, double b) {
        if (a > b) {
            return a;
        } else {
            return b;
        }
    }
    /**
     * Теперь, наш метод max будет также работать с переменными типа double.
     * Перегруженный метод должен также иметь другой список аргументов, параметры должны отличаться типом или количеством, или и тем и другим.
     * Другим названием для перегрузки методов является полиморфизм времени компиляции.
     * */
    /**
     * -----АБСТРАКЦИЯ-----
     * Абстракция данных предоставляет внешнему миру только основную информацию, т.е. только главные особенности, не включая детали реализации.
     * Хорошим жизненным примером является книга. Когда вы слышите термин книга, вы не знаете точных специфик, таких как количество страниц, цвет,
     * размер, но вы понимаете идею, или абстракцию, книги.
     * Концепцией абстракции является то, что мы фокусируемся на основных характеристиках, а не на специфических характеристиках одного отдельного примера.
     *
     * В Java, абстракция достигается с помощью абстрактных классов и интерфейсов.
     *
     * Абстрактный класс определяется с помощью ключевого слова abstract.
     * - Если объявленный класс является абстрактным, то он не может инстанцироваться (вы не можете создать объекты этого типа).
     * - Чтобы использовать абстрактный класс, вам необходимо наследовать его от другого класса.
     * - Любой класс, содержащий абстрактный метод, должен быть определен как абстрактный.
     *
     * Абстрактный метод это метод, который объявлен без реализации (без скобок, заканчивается точкой с запятой): abstract void walk();
     * Пример абстрактного класса рассмотрен в папке Starter_1
     *
     * -----ИНТЕРФЕЙС-----
     * Интерфейс это полностью абстрактный класс, который содержит только абстрактные методы.
     * Некоторые спецификации для интерфейсов:
     * - Определяются с помощью ключевого слова interface.
     * - Могут содержать только static final переменные.
     * - Не могут содержать конструктор, потому что интерфейсы не могут инстанцироваться.
     * - Интерфейсы могут расширять другие интерфейсы.
     * - Класс может реализовать любое количество интерфейсов.
     * Пример интерфейса рассмотрен в папке Starter_2
     *
     * Интерфейсы имеют следующие свойства:
     * - Интерфейс является полностью абстрактным. Вам не нужно использовать ключевое слово abstract при объявлении интерфейса.
     * - Каждый метод в интерфейсе является также полностью абстрактным, так что не нужно использовать ключевое слово abstract.
     * - Методы в интерфейсе являются полностью публичными.
     *
     * Класс может наследоваться лишь от одного суперкласса, но может реализовывать множество интерфейсов!
     *
     * Используйте ключевое слово implements, чтобы использовать интерфейс вместе с вашим классом.
     * */
}
